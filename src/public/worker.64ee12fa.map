{"version":3,"sources":["..\\node_modules\\promise-worker\\register.js","..\\app\\redux\\dispatcher\\worker.js"],"names":["customWorker","msg","NatType","ANY","EDM","EIM","OS","Windows","OSX","LINUX","tranformOSName","osName","toLowerCase","generatePeerPublicInfo","name","id","prepareLogs","logs","osCountMap","countryCountMap","peerIdMap","successfulConnections","failedConnections","tcpHpCount","udpHpCount","directCount","from","Date","forEach","log","i","index","hasOwnProperty","length","tcp_hole_punch_result","udp_hole_punch_result","is_direct_successful","isSuccess","isSuccessful","requesterPeerId","peer_requester","responderPeerId","peer_responder","includes","push","os","geo_info","country_name","createdAt","dateRange","to","applyFilter","filter","isNatTypeMatching","matches","NatType1","NatType2","nat_type","isOSMatching","OSType1","OSType2","isCountryMatching","CountryType1","CountryType2","isPeerIncluded","arr","indexOf","isPeerExcluded","IncludePeerId","ExcludePeerId","filterPieData","total","success","tcpResult","tcpHp","udpResult","udpHp","directResult","direct","data","type","payload","filteredLogs","item","search","RegExp"],"mappings":"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","file":"worker.64ee12fa.map","sourceRoot":"..\\public","sourcesContent":["'use strict'\n\nfunction isPromise (obj) {\n  // via https://unpkg.com/is-promise@2.1.0/index.js\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n}\n\nfunction registerPromiseWorker (callback) {\n  function postOutgoingMessage (e, messageId, error, result) {\n    function postMessage (msg) {\n      /* istanbul ignore if */\n      if (typeof self.postMessage !== 'function') { // service worker\n        e.ports[0].postMessage(msg)\n      } else { // web worker\n        self.postMessage(msg)\n      }\n    }\n    if (error) {\n      /* istanbul ignore else */\n      if (typeof console !== 'undefined' && 'error' in console) {\n        // This is to make errors easier to debug. I think it's important\n        // enough to just leave here without giving the user an option\n        // to silence it.\n        console.error('Worker caught an error:', error)\n      }\n      postMessage([messageId, {\n        message: error.message\n      }])\n    } else {\n      postMessage([messageId, null, result])\n    }\n  }\n\n  function tryCatchFunc (callback, message) {\n    try {\n      return { res: callback(message) }\n    } catch (e) {\n      return { err: e }\n    }\n  }\n\n  function handleIncomingMessage (e, callback, messageId, message) {\n    var result = tryCatchFunc(callback, message)\n\n    if (result.err) {\n      postOutgoingMessage(e, messageId, result.err)\n    } else if (!isPromise(result.res)) {\n      postOutgoingMessage(e, messageId, null, result.res)\n    } else {\n      result.res.then(function (finalResult) {\n        postOutgoingMessage(e, messageId, null, finalResult)\n      }, function (finalError) {\n        postOutgoingMessage(e, messageId, finalError)\n      })\n    }\n  }\n\n  function onIncomingMessage (e) {\n    var payload = e.data\n    if (!Array.isArray(payload) || payload.length !== 2) {\n      // message doens't match communication format; ignore\n      return\n    }\n    var messageId = payload[0]\n    var message = payload[1]\n\n    if (typeof callback !== 'function') {\n      postOutgoingMessage(e, messageId, new Error(\n        'Please pass a function into register().'))\n    } else {\n      handleIncomingMessage(e, callback, messageId, message)\n    }\n  }\n\n  self.addEventListener('message', onIncomingMessage)\n}\n\nmodule.exports = registerPromiseWorker\n","import Register from 'promise-worker/register';\r\nconst customWorker = (msg) => {    \r\n    const NatType = {\r\n        ANY: 'Any',\r\n        EDM: 'EDM',\r\n        EIM: 'EIM'\r\n    }\r\n\r\n    const OS = {\r\n        ANY: 'Any',\r\n        Windows: 'Windows',\r\n        OSX: 'MacOS',\r\n        LINUX: 'Linux'\r\n    }\r\n\r\n    // const PROTOCOL = {\r\n    //     ANY: 'Any',\r\n    //     // TCP_DIRECT: 'TCP_DIRECT',\r\n    //     UDP_HP: 'UDP_HP',\r\n    //     TCP_HP: 'TCP_HP'\r\n    // }\r\n\r\n    const tranformOSName = (osName) => {\r\n        switch (osName.toLowerCase()) {\r\n            case 'linux':\r\n                return OS.LINUX;\r\n            case 'macos':\r\n                return OS.OSX;\r\n            case 'windows':\r\n                return OS.Windows;\r\n            default:\r\n                return osName;\r\n        }\r\n    };\r\n\r\n    const generatePeerPublicInfo = (name, id) => {\r\n        return name + '(' + id + ')'\r\n    };\r\n\r\n    const prepareLogs = (logs) => {\r\n        const osCountMap = {};\r\n        const countryCountMap = {};\r\n        const peerIdMap = [];\r\n        const successfulConnections = [];\r\n        const failedConnections = [];\r\n        let tcpHpCount=0;\r\n        let udpHpCount=0;\r\n        let directCount=0;\r\n        let from = new Date;\r\n    \r\n        logs.forEach((log, i) => {\r\n            log.index = log.hasOwnProperty(\"index\") ? log.index : logs.length - i;\r\n            log.tcp_hole_punch_result === 'Succeeded' ? tcpHpCount++ : null;\r\n            log.udp_hole_punch_result === 'Succeeded' ? udpHpCount++ : null;\r\n            log.is_direct_successful? directCount++ : null;\r\n\r\n            const isSuccess = log.udp_hole_punch_result === 'Succeeded' || log.tcp_hole_punch_result === 'Succeeded' || log.is_direct_successful;\r\n            log.isSuccessful = isSuccess;\r\n    \r\n            const requesterPeerId = generatePeerPublicInfo(log.peer_requester.name, log.peer_requester.id);\r\n            const responderPeerId = generatePeerPublicInfo(log.peer_responder.name, log.peer_responder.id);\r\n            if (!peerIdMap.includes(requesterPeerId)) {\r\n                peerIdMap.push(requesterPeerId);\r\n            }\r\n            if (!peerIdMap.includes(responderPeerId)) {\r\n                peerIdMap.push(responderPeerId)\r\n            }\r\n    \r\n            log.peer_requester.os = tranformOSName(log.peer_requester.os);\r\n            log.peer_responder.os = tranformOSName(log.peer_responder.os);\r\n            if (!osCountMap[log.peer_requester.os]) {\r\n                osCountMap[log.peer_requester.os] = 0;\r\n            }\r\n            if (!osCountMap[log.peer_responder.os]) {\r\n                osCountMap[log.peer_responder.os] = 0;\r\n            }\r\n            osCountMap[log.peer_requester.os] = osCountMap[log.peer_requester.os] + 1;\r\n            osCountMap[log.peer_responder.os] = osCountMap[log.peer_responder.os] + 1;\r\n            if (!countryCountMap[log.peer_requester.geo_info.country_name]) {\r\n                countryCountMap[log.peer_requester.geo_info.country_name] = 0;\r\n            }\r\n            if (!countryCountMap[log.peer_responder.geo_info.country_name]) {\r\n                countryCountMap[log.peer_responder.geo_info.country_name] = 0;\r\n            }\r\n            countryCountMap[log.peer_requester.geo_info.country_name] = countryCountMap[log.peer_requester.geo_info.country_name] + 1;\r\n            countryCountMap[log.peer_responder.geo_info.country_name] = countryCountMap[log.peer_responder.geo_info.country_name] + 1;\r\n            if (from > new Date(log.createdAt)) {\r\n                from = new Date(log.createdAt);\r\n            }\r\n            (isSuccess ? successfulConnections : failedConnections).push(log);\r\n        });\r\n        return {\r\n            logs,\r\n            tcpHpCount,\r\n            udpHpCount,\r\n            directCount,\r\n            osCountMap,\r\n            countryCountMap,\r\n            peerIdMap,\r\n            successfulConnections,\r\n            failedConnections,\r\n            dateRange: {\r\n                from,\r\n                to: new Date\r\n            }\r\n        };\r\n    };\r\n\r\n    const applyFilter = (logs, filter) => {\r\n        const isNatTypeMatching = (log) => {\r\n            let matches = false;\r\n            if (filter.NatType1 === NatType.ANY && filter.NatType2 === NatType.ANY) {\r\n                matches = true;\r\n            } else if ((filter.NatType1 === NatType.ANY && filter.NatType2 !== NatType.ANY)) {\r\n                matches = (filter.NatType2 === log.peer_requester.nat_type || filter.NatType2 === log.peer_responder.nat_type)\r\n            } else if (filter.NatType2 === NatType.ANY && filter.NatType1 !== NatType.ANY) {\r\n                matches = (filter.NatType1 === log.peer_requester.nat_type || filter.NatType1 === log.peer_responder.nat_type)\r\n            } else if (filter.NatType1 !== NatType.ANY && filter.NatType2 !== NatType.ANY) {\r\n                matches = (log.peer_requester.nat_type === filter.NatType1 && log.peer_responder.nat_type === filter.NatType2) ||\r\n                    (log.peer_requester.nat_type === filter.NatType2 && log.peer_responder.nat_type === filter.NatType1)\r\n            }\r\n            return matches;\r\n        }\r\n    \r\n        const isOSMatching = (log) => {\r\n            let matches = false;\r\n            if (filter.OSType1 === OS.ANY && filter.OSType2 === OS.ANY)\r\n                matches = true;\r\n            else if ((filter.OSType1 === OS.ANY && filter.OSType2 !== OS.ANY))\r\n                matches = (filter.OSType2 === log.peer_requester.os || filter.OSType2 === log.peer_responder.os)\r\n            else if ((filter.OSType2 === OS.ANY && filter.OSType1 !== OS.ANY))\r\n                matches = (filter.OSType1 === log.peer_requester.os || filter.OSType1 === log.peer_responder.os)\r\n            else if (filter.OSType1 !== OS.ANY && filter.OSType2 !== OS.ANY)\r\n                matches = (log.peer_requester.os === filter.OSType1 && log.peer_responder.os === filter.OSType2) ||\r\n                    (log.peer_requester.os === filter.OSType2 && log.peer_responder.os === filter.OSType1)\r\n            return matches;\r\n        }\r\n    \r\n        // const isProtocolMatching = (log) => {\r\n        //     const { tcpHp, udpHp, direct } = filter.Protocol;\r\n        //     if (tcpHp && udpHp && direct) {\r\n        //         return true;\r\n        //     }\r\n        //     return (direct && log.is_direct_successful) ||\r\n        //         (tcpHp && log.tcp_hole_punch_result === 'Succeeded') ||\r\n        //         (udpHp && log.udp_hole_punch_result === 'Succeeded');\r\n        // }\r\n    \r\n        const isCountryMatching = (log) => {\r\n            const ANY = OS.ANY;\r\n            if (filter.CountryType1 === ANY && filter.CountryType2 === ANY)\r\n                return true;\r\n            else if ((filter.CountryType1 === ANY && filter.CountryType2 !== ANY))\r\n                return (filter.CountryType2 === log.peer_requester.geo_info.country_name || filter.CountryType2 === log.peer_responder.geo_info.country_name)\r\n            else if ((filter.CountryType2 === ANY && filter.CountryType1 !== ANY))\r\n                return (filter.CountryType1 === log.peer_requester.geo_info.country_name || filter.CountryType1 === log.peer_responder.geo_info.country_name)\r\n            else if (filter.CountryType1 !== ANY && filter.CountryType2 !== ANY)\r\n                return (log.peer_requester.geo_info.country_name === filter.CountryType1 && log.peer_responder.geo_info.country_name === filter.CountryType2) ||\r\n                    (log.peer_requester.geo_info.country_name === filter.CountryType2 && log.peer_responder.geo_info.country_name === filter.CountryType1)\r\n        }\r\n    \r\n        const isPeerIncluded = (arr, requesterPeerId, responderPeerId) => {\r\n            return arr.length === 0 ? true : (arr.indexOf(requesterPeerId) > -1 || arr.indexOf(responderPeerId) > -1);\r\n        }\r\n\r\n        const isPeerExcluded = (arr, requesterPeerId, responderPeerId) => {\r\n            return arr.length === 0 ? false : (arr.indexOf(requesterPeerId) > -1 || arr.indexOf(responderPeerId) > -1);\r\n        }\r\n\r\n        return logs.filter(log => {\r\n            const requesterPeerId = generatePeerPublicInfo(log.peer_requester.name, log.peer_requester.id);\r\n            const responderPeerId = generatePeerPublicInfo(log.peer_responder.name, log.peer_responder.id);\r\n            \r\n            return isNatTypeMatching(log) \r\n                && isOSMatching(log) \r\n                // && isProtocolMatching(log) \r\n                && isCountryMatching(log)\r\n                && isPeerIncluded(filter.IncludePeerId, requesterPeerId, responderPeerId)\r\n                && !isPeerExcluded(filter.ExcludePeerId, requesterPeerId, responderPeerId);\r\n        });\r\n    };\r\n\r\n    const filterPieData = (logs, filter) => {\r\n        let total = 0\r\n        let success = 0\r\n        logs.filter(log => {\r\n            total++;\r\n            const tcpResult = filter.tcpHp ? log.tcp_hole_punch_result === 'Succeeded' : false;\r\n            const udpResult = filter.udpHp ? log.udp_hole_punch_result === 'Succeeded' : false;\r\n            const directResult = filter.direct ? log.is_direct_successful : false;\r\n            if (tcpResult || udpResult || directResult) {\r\n                success++;\r\n            }\r\n        })\r\n        return {\r\n            data: {\r\n                total,\r\n                success\r\n            },\r\n            filter\r\n        };\r\n    }\r\n\r\n    const {type, payload} = msg;\r\n    switch(type) {\r\n        case 'PREPARE_LOGS':\r\n            return prepareLogs(payload);\r\n\r\n        case 'REVALIDATE':\r\n            const filteredLogs = applyFilter(payload.logs, payload.filter);\r\n            return prepareLogs(filteredLogs);\r\n        \r\n        case 'FILTER_PIE_CHART':\r\n            return filterPieData(payload.logs, payload.filter);\r\n        \r\n        case 'FILTER_NAME':\r\n            return payload.data.filter(item => item.search(new RegExp(payload.search,\"i\")) !== -1)\r\n        default:\r\n        return;\r\n    }\r\n};\r\n\r\nRegister(customWorker);"]}